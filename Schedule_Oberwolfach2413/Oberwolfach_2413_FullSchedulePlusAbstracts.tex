
\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{array}

\usepackage{color}
\usepackage[pdftex]{graphicx}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[breaklinks=true]{hyperref}


\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage{paralist}

%
%   \setlength{\textwidth}{7.0in}
%   \setlength{\textheight}{9.5in}
%   \setlength{\oddsidemargin}{-0.30in}
%   \setlength{\evensidemargin}{0.25in}
%   \setlength{\topmargin}{-1in}
%
\definecolor{lgray}{gray}{.8}
\newcommand{\xbox}{\colorbox{lgray}{ X }}


\newcommand{\scheduletablewidth}{5.06in}
% \newcommand{\scheduletablewidth}{5.7in}



\begin{document}



\begin{center}

  \Large{\bf
    Oberwolfach Workshop 2413: \\
    \textit{Proof Complexity and Beyond}  \\
    March 24--29, 2024}
\end{center}

\medskip

\begin{center}
{\bf GENERAL INFORMATION}
\end{center}

%%%
%%% DAGSTUHL GENERAL INFORMATION
%%%
%   
%   \begin{compactitem}
%   \item
%     Please be aware that you  will
%     need the username and password of your door account (i.e., the credentials
%     you used to register for the seminar)
%     while in Dagstuhl.
%   
%   \item
%     The Dagstuhl reception  is located in the facility opposite the
%     manor house. The reception is open from 15:00 to 19:00 on Sunday and
%     from 8:00 to 16:00 on other days. If it is closed when you
%     arrive, please use the access code in your voucher
%     to enter the building and then follow the self-service
%     check-in procedure described  at the reception.
%     Food is available on Sundays from 6 pm until the following morning.
%   
%   \item
%     Departure is on Friday after lunch.
%     Dagstuhl kindly asks you to clear your room by 9:00 and to pay your
%     bill for accommodation, meals and your private expenses on the day
%     of your departure before lunch.
%   
%   \end{compactitem}
%   

%%%
%%% OBERWOLFACH GENERAL INFORMATION
%%%

\begin{compactitem}

\item
  Sunday afternoon is the official arrival time and Oberwolfach opens
  at 16:30. The institute offers free taxi transfer from the train
  station in Hausach on Sunday evening
  at 16:30, 17:30, and~18:30.
  Please check in at the reception from 17:00 to~19:00 or via the
  early/late arrivals list placed opposite the reception.

\item
  Departure is on Friday after lunch.
  Check-out time from the rooms is at 9:30. There will be
  lunch at 12:30 but no dinner. Oberwolfach will
  organize a number of free taxi transfers to the train
  station in Hausach on Friday afternoon or evening.
\end{compactitem}



\begin{center}
{\bf MEALS}
\end{center}

%%%
%%% BIRS MEAL TIMES
%%%
%   \noindent
%   *Breakfast (Buffet): 7:00--9:30, Sally Borden Building, Monday--Friday\\
%   *Lunch (Buffet): 11:30--13:30, Sally Borden Building, Monday--Friday\\
%   *Dinner (Buffet): 17:30--19:30, Sally Borden Building, Sunday--Thursday\\
%   Coffee Breaks:  As per daily schedule,
%   in the foyer of the TransCanada Pipeline Pavilion (TCPL)\\
%   {\bf *Please remember to scan your meal card at the host/hostess
%   station in the dining room for each meal.}
%


%%%
%%% DAGSTUHL MEAL TIMES
%%%
%   
%   \begin{compactitem}
%   \item
%     Breakfast is served from  7:30 to 8:45.
%   \item
%     Lunch is served at 12:15.
%   \item
%     Dinner is served at 18:00.
%   \item
%     During the morning break,
%     coffee and tea are available outside the seminar room.
%   \item
%     In the afternoon, coffee and cake are served between 15:00 and 16:00
%     in the dinner hall.
%   \end{compactitem}
%   

%%%
%%% OBERWOLFACH MEAL TIMES
%%%

\begin{compactitem}
\item
  Breakfast is served from  8:00 to 9:00.
\item
  Lunch is served at 12:30.
\item
  Cake is served 15:00--16:00 (except on Wednesday).
\item
  Dinner is served at 18:30.
\end{compactitem}


%%%
%%% BIRS ROOMS
%%%
%   \begin{center}
%   {\bf MEETING ROOMS}
%   \end{center}
%
%   \noindent
%   All lectures will be held in the lecture theater in the TransCanada
%   Pipelines Pavilion (TCPL). An LCD projector, a laptop, a document
%   camera, and blackboards are available for presentations.
%

\medskip

\begin{center}
{\bf SCHEDULE }
\end{center}

\noindent\begin{minipage}{\textwidth}
\begin{center} {\bf\large Sunday March 24} \end{center}
\begin{tabular}{ p{0.9in} p{\scheduletablewidth} }
%   {\bf 16:00}
%   {\bf 15:00}
%     & Dagstuhl reception opens
{\bf 17:00--19:00}
  & Check-in
%   Check-in begins
%   (Front Desk -- Professional Development Centre --  open 24 hours)\\
%   {\bf 17:30--19:30} & Buffet Dinner, Sally Borden Building
\\
%   {\bf 18:00--} & Buffet dinner\\
{\bf 18:30--} & Dinner\\
%   {\bf 19:00}   & Dagstuhl reception closes \\
  {\bf 20:00--} & Informal gathering 
%   %    in 2nd floor lounge, Corbett Hall
%   in the lounge in the Dagstuhl castle
in the lounge
(if desired)
  \\
%         &Beverages and a small assortment of snacks are available on a
%           cash honour system.\\
  \\
\end{tabular}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{center}
{\bf\large Monday October 10}
\end{center}
\begin{tabular}{ p{0.9in} p{\scheduletablewidth} }
%\begin{center}
%\begin{tabular}{ m{1cm} m{10cm} }
{\bf 07:30--08:45}  & Breakfast\\
{\bf 08:45--09:00}  &
%                       Introduction and
                    Welcome
%       by the BIRS Station Manager, TCPL
\\

{\bf 09:00--09:55} & \hyperref[Beyersdorff]{Olaf Beyersdorff}
{\em Theory and Practice of SAT Solving} \\

{\bf 09:55--10:50} & \hyperref[Biere]{Armin Biere}
{\em Trusting SAT Solvers} \\


{\bf 10:50--11:10} & Coffee break \\


{\bf 11:10--12:05} & \hyperref[Williams]{Ryan Williams}
{\em Around the Complexity of SAT} \\

{\bf 12:15%--13:00
} &  Lunch\\

{\bf 14:00--14:55} & \hyperref[Nordstrom]{Jakob Nordström}
{\em Proof complexity and SAT solving} \\

{\bf 15:00--15:40} &  Coffee and cake \\

{\bf 15:40--16:35} & \hyperref[Rezende]{Susanna F. de Rezende}
{\em Theoretical Barriers for Efficient Proof Search (a Survey)} \\

{\bf 16:35--17:30} & \hyperref[Kaufmann]{Daniela Kaufmann}
{\em Exploring Algebraic Methods for Circuit Verification} \\

{\bf 17:30--18:00} & Presentation of participants \\

{\bf 18:00%--19:30
} & Dinner \\
\end{tabular}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{center} {\bf\large Tuesday October 11} \end{center}
\begin{tabular}{ p{0.9in} p{\scheduletablewidth} }
{\bf 07:30--08:45}  & Breakfast \\


{\bf 09:00--09:55} & \hyperref[Mahajan]{Meena Mahajan}
{\em Quantified Boolean Formulas: Solving and Proof Complexity} \\

{\bf 09:55--10:50} & \hyperref[McCreesh]{Ciaran McCreesh}
{\em How Constraint Programming Isn't Like SAT} \\

{\bf 10:50--11:10} & Coffee break \\

{\bf 11:10--12:05} & \hyperref[Bjorner]{Nikolaj Bjørner}
{\em An Introduction to SMT with Proofs} \\

{\bf 12:15%--13:30
} & Lunch \\

 & Afternoon break \\

{\bf 15:00--16:00} & \hyperref[Schidler]{Andre Schidler, Friedrich Slivovski, and Stefan Szeider}
{\em Scalable optimization with SAT-based local improvement (SLIM)} \\

{\bf 16:00--16:30} & Coffee and cake \\

{\bf 16:30--17:00} & \hyperref[Jarvisalo]{Matti Järvisalo}
{\em Pseudo-Boolean Optimization by Implicit Hitting Sets} \\

{\bf 17:00--17:30} & \hyperref[Fazekas]{Katalin Fazekas}
{\em On Design Decisions of Extending CDCL with External Propagators} \\

{\bf 17:30--18:00} & \hyperref[Li]{Chunxiao (Ian) Li}
{\em Towards a Deeper Understanding of Modern CDCL SAT Solvers} \\

{\bf 18:00} & Dinner \\
\end{tabular}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{center} {\bf\large Wednesday October 12} \end{center}
\begin{tabular}{ p{0.9in} p{\scheduletablewidth} }

{\bf 07:30--08:45} & Breakfast \\

{\bf 09:00--09:55} & \hyperref[Kovacs]{Laura Kovács and Martin Suda}
{\em First-Order Theorem Proving} \\

{\bf 09:55--10:50} & \hyperref[Gleixner]{Ambros Gleixner}
{\em Algorithmic Mixed Integer Programming: Between Exactness and Performance in Theory and Practice} \\

{\bf 10:50--11:10} & Coffee break \\

{\bf 11:10--12:05} & \hyperref[Helmert]{Malte Helmert}
{\em Introduction to Automated Planning} \\

{\bf 12:15%--13:30
} & Lunch\\
{\bf } & Free afternoon \\
{\bf 18:00} & Dinner \\
\end{tabular}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{center} {\bf\large Thursday October 13} \end{center}
\begin{tabular}{ p{0.9in} p{\scheduletablewidth} }

{\bf 07:30--08:45} & Breakfast  \\

{\bf 09:00--09:55} & \hyperref[FleuryInvited]{Mathias Fleury}
{\em Verifying Solvers: How Much Do You Want to Prove?} \\

{\bf 09:55--10:50} & \hyperref[Tan]{Yong Kiam Tan}
{\em The Last Mile in Trustworthy Automated Reasoning} \\

{\bf 10:50--11:00} & Coffee break \\

{\bf 11:00--11:30} & \hyperref[Oertel]{Andy Oertel}
{\em Certified CNF Translations for Pseudo-Boolean Solving} \\

{\bf 11:30--12:00} & \hyperref[Bogaerts]{Bart Bogaerts}
{\em On Proof Logging and Symmetry Handling} \\

{\bf 12:15%--13:30
} & Lunch \\

 & Afternoon break \\

{\bf 15:00--15:30} & \hyperref[Yolcu]{Emre Yolcu}
{\em Exponential separations using guarded extension variables} \\

{\bf 15:30--16:00} & \hyperref[Berg]{Jeremias Berg}
{\em Clause Redundancy and Preprocessing in Maximum Satisfiability} \\

{\bf 16:00--16:30} & Coffee and cake \\

{\bf 16:30--17:00} & \hyperref[Heule]{Marijn Heule}
{\em The Packing Chromatic Number of the Infinite Square Grid is 15} \\

{\bf 17:00--18:00} & Open problem session \\

{\bf 18:00} & Dinner \\
\end{tabular}
\end{minipage}

\noindent\begin{minipage}{\textwidth}
\begin{center} {\bf\large Friday October 14} \end{center}
\begin{tabular}{ p{0.9in} p{\scheduletablewidth} }

{\bf 7:30--8:45}  & Breakfast\\

{\bf 9:00--9:30}  & \hyperref[Meel]{Kuldeep Meel}
{\em Designing Samplers is Easy: The Boon of Testers}\\

{\bf 9:30--10:00}  &  \hyperref[Bohm]{Benjamin Böhm}
{\em CDCL vs resolution: the picture in QBF}\\

{\bf 10:00--10:30}  &  \hyperref[Vinyals]{Marc Vinyals}
{\em Theoretical limits of 1UIP Learning}\\

{\bf 10:30--11:00} & Coffee break \\

{\bf 11:00--11:30}  &  \hyperref[FleuryContributed]{Mathias Fleury and Armin Biere}
{\em Discussion: How to combine and compare options in solvers?}\\

{\bf 11:30--12:00}  &  \hyperref[Ganesh]{Vijay Ganesh}
{\em A SAT Solver + Computer Algebra Attack on the Minimum Kochen-Specker Problem}\\

{\bf 12:15%--13:30
} & Lunch\\
\end{tabular}
\end{minipage}


\pagebreak

% \textbf{HERE ABSTRACTS SHOULD FOLLOW IN
% ALPHABETIC ORDER W.R.T. SPEAKER --- ERASE THIS LINE}

\subsection*{Jeremias Berg: Clause Redundancy and Preprocessing in Maximum Satisfiability}\label{Berg}

The study of clause redundancy in Boolean satisfiability (SAT) has proven significant
in various terms, from fundamental insights into preprocessing and inprocessing to
the development of practical proof checkers and new types of strong proof systems.
I will present our recent work on liftings of the recently-proposed notion of propagation
redundancy --- based on a semantic implication relationship between formulas --- in the
context of maximum satisfiability (MaxSAT), where of interest are reasoning techniques that preserve
optimal cost (in contrast to preserving satisfiability in the realm of SAT).
We establish the strongest MaxSAT-lifting of propagation redundancy allows for changing in a controlled way
the set of minimal correction sets in MaxSAT. This ability is key in succinctly expressing MaxSAT reasoning techniques and allows for obtaining correctness proofs in a uniform way for  MaxSAT reasoning techniques very generally. I will also highlight some interesting directions for future work.


\subsection*{Olaf Beyersdorff: Theory and Practice of SAT Solving}\label{Beyersdorff}

This talk will provide a survey on the relations between proof complexity and SAT solving. What can proof complexity tell us about the strength and limitations of SAT solving? Why should practitioners be interested in proof complexity results and why should theorists study SAT solving? What have we achieved in the past 25 years and which problems remain open?


\subsection*{Armin Biere: Trusting SAT Solvers}\label{Biere}

Many critical applications crucially rely on the correctness of SAT solvers. Particularly in the context of formal verification, the claim by a SAT solver that a formula is unsatisfiable corresponds to a safety or security property to hold, and thus needs to be trusted.  In order to increase the level of trust an exciting development in this century was to let SAT solvers produce certificates, i.e., by tracing proofs of unsatisfiability, which can independently be checked.  In the last ten years this direction of research gained substantial momentum, e.g., solvers in the main track of the SAT competition are required to produce such certificates and industrial applications of SAT solvers require that feature too.  In this talk we review this quarter of century of research in certifying the result of SAT solvers, discuss briefly alternatives, including testing approaches and verifying the SAT solver directly, mention exciting research on new proof systems produced in this context as well as how these ideas extend beyond formulas in conjunctive normal form.


\subsection*{Nikolaj Bjørner: An Introduction to SMT with Proofs}\label{Bjorner}

The talk provides an overview of selected current trends in SMT solving theories and techniques. An active area of discussion in the SMT community is around proof formats for SMT solvers. I give an introduction to current approaches pursued in solvers such as Z3, CVC5, VeriT and SMTInterpol.


\subsection*{Benjamin Böhm: CDCL vs resolution: the picture in QBF}\label{Bohm}

This talk will cover the relations between QBF resolution and QCDCL solving algorithms. Modelling QCDCL as proof systems we show that QCDCL and Q-Resolution are incomparable. We also introduce new versions of QCDCL that turn out to be stronger than the classic models.

This talk is based on a couple of recent papers (joint with Olaf Beyersdorff and Tomas Peitl, which appeared in ITCS'21, SAT'21, SAT'22 and IJCAI'22).


\subsection*{Bart Bogaerts: On Proof Logging and Symmetry Handling}\label{Bogaerts}

In this talk, we take a deep-dive in the fascinating world of symmetry handling for Boolean Satisfiability, by reviewing static and dynamic techniques.  We focus on proof logging techniques for these symmetry handling methods. We end with some open problems and challenges.


\subsection*{Susanna F. de Rezende: Theoretical Barriers for Efficient Proof Search (a Survey)}\label{Rezende}

The proof search problem is a central question in automated theorem proving and SAT solving. Clearly, if a propositional tautology F does not have a short (polynomial size) proof in a proof system P, any algorithm that searches for P-proofs of F will necessarily take super-polynomial time. But can proofs of ``easy'' formulas, i.e., those that have polynomial size proofs, be found in polynomial time? This question motivates the study of automatability of proof systems. In this talk, we give an overview of known non-automatability results, focusing on the more recent ones, and present some of the main ideas used to obtain them.


\subsection*{Katalin Fazekas: On Design Decisions of Extending CDCL with External Propagators}\label{Fazekas}

Solving combinatorial problems often combines SAT solving with different
reasoning techniques. An external propagator can interpret the partial assignment built by the SAT solver during search and, based on such different reasoning methods, can construct clauses that are propagating or conflicting under that assignment. The use of such external propagators allows to directly guide the search of the SAT solver into a preferred direction, which can make problem solving in several problem domains more efficient (consider e.g. dynamic symmetry breaking). However, both the efficient combination of external propagators with the complex features of modern SAT solvers (e.g. proof logging and inprocessing), and the theoretical understanding of such combined reasoning methods are open problems.

This talk, based on current work in progress, presents some of the design decisions that must be considered when external propagation is combined with modern CDCL solvers. We describe some challenges and formulate both practical and theoretical open questions about how to implement external propagation in CDCL in the presence of current SAT solver features such as proof logging, clause database reduction and inprocessing.


\subsection*{Mathias Fleury: Verifying Solvers: How Much Do You Want to Prove?}\label{FleuryInvited}

In this talk, I present the two main approaches to verify solvers: partial verification (usually bottom-up from code to the specification) and complete verification (usually top-down from the specification towards the code). The former approach present many similarities to verify checkers, whereas the latter starts with a full formalization of underlying algorithm. I compare the approaches and show where the main challenges are.


\subsection*{Mathias Fleury and Armin Biere: Discussion: How to combine and compare options in solvers?}\label{FleuryContributed}

% TODO: The schedule says that Mathias is giving the talk alone, what is correct?

Comparing options between solvers is a complicated
task. There are three main ways: runtime options (with the risk
of not understanding requirements between features), compile-time
option (with the issue of testing and making the code very
complicated), or different versions of the source code. A second
question is how to measure the performance without implementing
the most advanced version. This (short) talk should serve as a
basis for discussion on how to organize the development of a
solver with various options.


\subsection*{Vijay Ganesh: A SAT Solver + Computer Algebra Attack on the Minimum Kochen-Specker Problem}\label{Ganesh}

One of the most fundamental results in the foundations of quantum mechanics is the Kochen--Specker (KS) theorem, a `no-go' theorem which states that contextuality is an essential feature of any hidden-variable theory. The theorem hinges on the existence of a mathematical object called a KS vector system. Although the existence of a KS vector system was first established by Kochen and Specker, the problem of the minimum size of such a system has stubbornly remained open for over 50 years. In this paper, we present a new method based on a combination of a SAT solver and a computer algebra system (CAS) to address this problem. We improve the lower bound on the minimum number of vectors in a KS system from 22 to 23 and improve the efficiency of the search by a factor of over 1000 when compared to the most recent computational methods.  Finding a minimum KS system would simplify experimental tests of the KS theorem and have direct applications in quantum information processing, specifically in the security of quantum cryptographic protocols based on complementarity, zero-error classical communication, and dimension witnessing.



\subsection*{Ambros Gleixner: Algorithmic Mixed Integer Programming: Between Exactness and Performance in Theory and Practice}\label{Gleixner}

Today's state-of-the-art solvers for the general class of mixed integer programs exhibit both exact and heuristic properties. Both aspects are crucial for their lasting relevance in academic and industrial practice.  In this talk, we give an overview of methods implemented and successfully used in mixed-integer programming solvers and try to point out connections to satisfiability solving and pseudo-Boolean optimization.  We conclude by outlining our efforts to address the ubiquitous use of floating-point arithmetic in virtually all fast mixed integer programming solvers and report advances in performant roundoff-error-free MIP solving with proof logging.


\subsection*{Malte Helmert: Introduction to Automated Planning}\label{Helmert}

In my talk, I will introduce the classical planning problem and explain its relevance to the seminar by contrasting it with SAT. For those that haven't seen planning before, I hope to provide some basic understanding of the problem and why it is of interest. For those familiar with planning, I hope to give one or two additional perspectives on the problem and its complexity. Time permitting, I will also update the seminar participants on research in the planning community that tackles the main motivating questions of the seminar, in particular discussing results and open challenges for certifying planning algorithms.


\subsection*{Marijn Heule: The Packing Chromatic Number of the Infinite Square Grid is 15}\label{Heule}

A packing $k$-coloring of a graph $G = (V, E)$ is a mapping from $V$ to $\{1, \ldots, k\}$ such that any pair of vertices $u, v$ that receive the same color $c$ must be at distance greater than $c$ in $G$. Arguably the most fundamental problem regarding packing colorings is to determine the packing chromatic number of the infinite square grid. Various works in the last 20 years improved the bounds of this problem. We finally solve it and show that the answer is 15. A crucial part of our solution is a novel encoding that reduces the runtime by a factor of 30. Moreover, we construct and validate a DRAT proof of unsatisfiability for the direct encoding of the problem. This proof includes the symmetry-breaking and reencoding techniques that we applied.


\subsection*{Matti Järvisalo: Pseudo-Boolean Optimization by Implicit Hitting Sets}\label{Jarvisalo}

Recent developments in applying and extending Boolean satisfiability (SAT) based techniques have resulted in new types of approaches to pseudo-Boolean optimization (PBO), complementary to the more classical integer programming techniques. In this paper, we develop the first approach to pseudo-Boolean optimization based on instantiating the so-called implicit hitting set (IHS) approach, motivated by the success of IHS implementations for maximum satisfiability (MaxSAT). In particular, we harness recent advances in native reasoning techniques for pseudo-Boolean constraints, which enable efficiently identifying inconsistent assignments over subsets of objective function variables (i.e. unsatisfiable cores in the context of PBO), as a basis for developing a native IHS approach to PBO, and study the impact of various search techniques applicable in the context of IHS for PBO.

This talk is based on the following papers:
\begin{itemize}
  \item Improvements to the Implicit Hitting Set Approach to Pseudo-Boolean Optimization. Pavel Smirnov, Jeremias Berg, and Matti Järvisalo. SAT 2022
  \item Pseudo-Boolean Optimization by Implicit Hitting Sets. Pavel Smirnov, Jeremias Berg, and Matti Järvisalo. CP 2021
\end{itemize}


\subsection*{Daniela Kaufmann: Exploring Algebraic Methods for Circuit Verification}\label{Kaufmann}

Digital circuits are widely utilized in computers, because they provide models for various digital components and arithmetic operations. To avoid problems like the infamous Pentium FDIV bug, it is critical to ensure that these circuits are correct. Formal verification can be used to evaluate whether a circuit meets a given specification. Arithmetic circuits, in particular integer multipliers, pose a challenge to current verification approaches. Techniques that rely solely on SAT solving or decision diagrams appear incapable of tackling this problem in an acceptable period of time. In practice, circuit verification still requires a substantial amount of manual labor.

In this talk, we will demonstrate an automated verification technique that is based on algebraic reasoning and is currently considered to be one of the most successful verification methods for circuit verification. In this approach the circuit is modeled as a set of polynomial equations that is implied by the circuit. For a correct circuit, we must demonstrate that the specification is implied by the polynomial representation of the given circuit. However, some sections of the multiplier, such as final stage adders, are difficult to check using simply computer algebra. To address this issue, we will provide a hybrid solution that blends SAT and computer algebra.

But who verifies the verifier? The ability to independently generate and check proof certificates boosts confidence in the outcomes of automated reasoning tools. We present an algebraic proof calculus that allows us to obtain certificates as a by-product of circuit verification and that can be efficiently verified with our independent proof checking tools.


\subsection*{Laura Kovács and Martin Suda: First-Order Theorem Proving}\label{Kovacs}

First-order theorem proving is undergoing a rapid development thanks to its successful use in software analysis, formal verification, IT security, symbolic computation, theorem proving in mathematics, and other related areas. Breakthrough results in all areas of theorem proving have been obtained, including improvements in theory, implementation, and the development of powerful theorem proving tools.

This talks serves as a mini-tutorial on the theory and practice of first-order theorem proving. We introduce the core concepts of automating first-order theorem proving in first-order logic with equality. We will discuss the resolution and superposition calculus, introduce the saturation principle, present various algorithms implementing redundancy elimination, and demonstrate how these concepts are implemented in our Vampire theorem prover. We survey practical consideration for making saturation efficient and focus on applications of SAT solvers in the efficient automation of first-order reasoning.


\subsection*{Chunxiao (Ian) Li: Towards a Deeper Understanding of Modern CDCL SAT Solvers}\label{Li}

Understanding why state-of-the-art SAT solvers are empirically successful has been a long standing question since the beginning of solver research. An ideal answer to the question should be both empirically verifiable, and in the same time can be theoretically analyzed. To shed light on this difficult problem, I will present a novel concept for SAT formulas and proofs, namely the hierarchical community structure (HCS). Empirically we show that hierarchical community structure can be used to distinguish industrial formulas from random, crafted and crypto formulas. And theoretically, we prove size upper bounds parameterized in the HCS structure. I will also discuss some recent developments in the proof locality through the lens of HCS.


\subsection*{Meena Mahajan: Quantified Boolean Formulas: Solving and Proof Complexity}\label{Mahajan}

QBF solving brings many new challenges and has thrown up many innovative approaches and heuristics. QBF proof complexity explores the theoretical underpinnings of these approaches rigorously, explains relative strengths of different approaches, exposes limitations, and suggests new approaches. This talk will survey some of the developments in the area.


\subsection*{Ciaran McCreesh: How Constraint Programming Isn't Like SAT}\label{McCreesh}

This talk provides an overview of modern constraint programming and how it differs from SAT solving, both in technology and terminology. I'll give an introduction to how the CP community thinks and speaks, starting with modelling and reformulation; then constraints, propagation, and lazy clause generation; and finally, search. Next we'll take a closer look at the all-different constraint: I'll explain how it's propagated and why CNF can't do the same thing, and then we'll look at whether stronger propagation is actually a good idea in practice. I'll conclude with a look at three exciting research topics: proof logging, belief propagation, and parallel search.


\subsection*{Kuldeep Meel: Designing Samplers is Easy: The Boon of Testers}\label{Meel}

Uniform sampling is a fundamental problem with a wide variety of applications. Recently, Chakraborty and Meel designed the first scalable sampling tester, Barbarik, based on a grey-box sampling technique for testing if the distribution, according to which the given sampler is sampling, is close to the uniform or far from uniform. The availability of Barbarik has the potential to spur the development of samplers and testing techniques such that developers can design sampling methods that can be accepted by Barbarik even though these samplers may not be amenable to a detailed mathematical analysis.

In this work, we present the realization of this aforementioned promise. Based on the flexibility offered by CryptoMiniSat, we design a sampler CMSGen that promises the achievement of the sweet spot of the quality of distributions and runtime performance. In particular, CMSGen achieves significant runtime performance improvement over the existing samplers. We conduct two case studies, and demonstrate that the usage of CMSGen leads to significant runtime improvements in the context of combinatorial testing and functional synthesis.

(Joint work with Priyanka Golia, Mate Soos, and Sourav Chakraborty)


\subsection*{Jakob Nordström:
  Proof Complexity and SAT Solving}\label{Nordstrom}

This talk is intended to give an overview of proof complexity and
connections to Boolean satisfiability (SAT) solving. The focus will be
on proof systems (and corresponding algorithms) such as resolution
(DPLL and conflict-driven clause learning), Nullstellensatz and
polynomial calculus (linear algebra and Gröbner basis computations),
and cutting planes (pseudo-Boolean solving and $0$-$1$ integer linear
programming). We will also discuss briefly proof systems such as
Sherali-Adams and sums of squares (linear programming and semidefinite
programming hierarchies), stabbing planes (0-1 ILP), and extended
resolution (SAT pre- and inprocessing).


\subsection*{Andy Oertel: Certified CNF Translations for Pseudo-Boolean Solving}\label{Oertel}

The dramatic improvements in Boolean satisfiability (SAT) solving since the turn of the millennium have made it possible to leverage state-of-the-art conflict-driven clause learning (CDCL) solvers for many combinatorial problems in academia and industry, and the use of proof logging has played a crucial role in increasing the confidence that the results these solvers produce are correct. However, the fact that SAT proof logging is performed in conjunctive normal form (CNF) clausal format means that it has not been possible to extend guarantees of correctness to the use of SAT solvers for more expressive combinatorial paradigms, where the first step is an unverified translation of the input to CNF.

In this work, we show how cutting-planes-based reasoning can provide proof logging for solvers that translate pseudo-Boolean (a.k.a. 0-1 integer linear) decision problems to CNF and then run CDCL. To support a wide range of encodings, we provide a uniform and easily extensible framework for proof logging of CNF translations. We are hopeful that this is just a first step towards providing a unified proof logging approach that will also extend to maximum satisfiability (MaxSAT) solving and pseudo-Boolean optimization in general.

This is joint work with Stephan Gocht, Ruben Martins and Jakob Nordström.


\subsection*{Andre Schidler, Friedrich Slivovski, and Stefan Szeider: Scalable optimization with SAT-based local improvement (SLIM)}\label{Schidler}

% TODO: The references in the abstract don't match up the references given (reference [7] and [9]) ---

SAT-based local improvement (SLIM) is an optimization metaheuristic. It repeatedly employs SAT-based solvers to local versions of the problem instance at hand, gradually improving a heuristically computed initial global solution. SLIM has been successfully instantiated for several problems, including graph decomposition and coloring, decision tree induction, Bayesian network structure learning, and circuit synthesis.

% \noindent[1] J. K. Fichte, N. Lodha, and S. Szeider. SAT-based local improvement for finding tree decompositions of small width. SAT 2017.

% \noindent[2] N. Lodha, S. Ordyniak, and S. Szeider. A SAT approach to branchwidth. ACM Trans. Comput. Log., 20(3):15:1–15:24, 2019.

% \noindent[3] V. Peruvemba Ramaswamy and S. Szeider. Turbocharging Treewidth-Bounded Bayesian Network Structure Learning. AAAI 2021.

% \noindent[4] V. Peruvemba Ramaswamy and S. Szeider. Learning Large Bayesian Networks with Expert Constraints. UAI 2022.

% \noindent[5] V. Peruvemba Ramaswamy and S. Szeider. MaxSAT-based postprocessing for treedepth. CP 2020.

% \noindent[6] F. Reichl, F. Slivovsky, and S. Szeider. Circuit Minimization with QBF-Based Exact Synthesis. manuscript. See \url{https://www.iwls.org/iwls2022/} programming contest, 2022.


\subsection*{Yong Kiam Tan: The Last Mile in Trustworthy Automated Reasoning}\label{Tan}

State-of-the-art automated reasoning tools are complex and highly-optimized pieces of software. This complexity can lead to an increased risk of soundness-critical bugs, which may affect the trustworthiness of automatically generated results. To remedy this state of affairs, many tools now generate proof logs (or proof certificates), which can be independently checked for correctness.

This talk is about the ``last mile'' in highly trustworthy automated reasoning---the development of efficient, formally verified proof checkers that are capable of soundly scrutinizing proof logs for various theories. I will survey theories, proof systems, and proof checkers that have been formalized in proof assistants, including my work with various collaborators on verifying proof checkers using HOL4 and CakeML. Looking ahead, I speculate that today's foundational software verification tools are well-suited to handle tougher challenges in end-to-end verification of proof checkers. For example, 1) building common infrastructure to ease verification of new proof systems and/or efficient proof checkers; 2) developing a unified proof checker that seamlessly handles proofs from different theories; or 3) verifying proof checkers for proof systems that feature probabilistic or interactive elements.


\subsection*{Marc Vinyals: Theoretical limits of 1UIP Learning}\label{Vinyals}

Even though CDCL can reproduce resolution proofs with at most a polynomial overhead, it is not clear how large that overhead needs to be, or if one is needed at all. We investigate the role that learning schemes play in this simulation by focusing on syntactical properties of proofs generated by CDCL solvers that employ the standard 1UIP learning scheme. In particular we show that proofs of this kind can simulate resolution proofs with at most a linear overhead, but there also exist formulas where such overhead is necessary or, more precisely, that there exist formulas with resolution proofs of linear length that require quadratic CDCL proofs.


\subsection*{Ryan Williams: Around the Complexity of SAT}\label{Williams}

I'll do my best to give a gentle overview of the state of the art in worst-case SAT solving, as of October 2022. We'll talk briefly about the algorithms, and also about impossibility conjectures. We'll see the Exponential Time Hypothesis (ETH), the Strong ETH, and even the Super Strong ETH, which are increasingly stronger assertions about how hard SAT is to solve in the worst case. We'll see some of the vast implications of these hypotheses, and discuss their potential truth (or falsity).


\subsection*{Emre Yolcu: Exponential separations using guarded extension variables}\label{Yolcu}

We study the complexity of proof systems augmenting resolution with inference rules that allow, given a formula $F$ in conjunctive normal form, deriving clauses that are not necessarily logically implied by $F$ but whose addition to $F$ preserves satisfiability. When the derived clauses are allowed to introduce variables not occurring in $F$, the systems we consider become equivalent to extended resolution. We are concerned with the versions of these systems ``without new variables.'' They are called BC-, RAT-, SBC-, and GER-, denoting respectively blocked clauses, resolution asymmetric tautologies, set-blocked clauses, and generalized extended resolution. Each of these systems formalizes some restricted version of the ability to make assumptions that hold ``without loss of generality,'' which is commonly used informally to simplify or shorten proofs. Except for SBC-, these systems are known to be exponentially weaker than extended resolution. They are, however, all equivalent to it under a relaxed notion of simulation that allows the translation of the formula along with the proof when moving between proof systems. By taking advantage of this fact, we construct formulas that separate RAT- from GER- and vice versa. With the same strategy, we also separate SBC- from RAT-. Additionally, we give polynomial-size SBC- proofs of the pigeonhole principle, which separates SBC- from GER- by a previously known lower bound. These results also separate the three systems from BC- since they all simulate it. We thus give an almost complete picture of their relative strengths.

\end{document}

